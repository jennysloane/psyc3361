# Study 2 (aka Leverhulme Study 7 - Conflict)


#The goal of checkpoint is to solve the problem of package reproducibility in R. Specifically, checkpoint solve the problems that occur when you donâ€™t have the correct versions of R packages. Since packages get updated on CRAN, it can be difficult to recreate an environment where all your packages are consistent with some earlier state.
#To solve this, checkpoint allows you to install packages from a specific snapshot date. 
install.packages("checkpoint") #install
library(checkpoint) #load
checkpoint("2020-11-20") #set date


#INSTALL PACKAGES  

install.packages("httr")        #'httr' is used for downloading data from OSF
install.packages("qualtRics")    #qualtRics is designed to read .csv files generated by Qualtrics  - I used this package because it overcomes one of the big issues with opening Qualtrics .csv files in R (i.e., that rows 2 and 3 in Qualtrics files are text, therefore the usual 'read.csv' command reads the colums as 'characters' or 'string' rather than 'numeric' http://adrianbruegger.com/import-qualtrics-csv-files/)    Full details https://cran.csiro.au/web/packages/qualtRics/qualtRics.pdf 
install.packages("tidyr")    #tidyr for splitting column using delimiter 
install.packages("reshape2")   #reshape2 used for melting data to long Format 
install.packages("psych")    #for summary statistics 
install.packages("yarrr")    #yarrr for creating pirate plot 
install.packages("car")
install.packages("effectsize")
install.packages("BayesFactor") #for Bayesian Anova
install.packages("foreign") #for ordinal regression
install.packages("ggplot2")
install.packages("MASS")
install.packages("Hmisc")
install.packages("reshape2")


#LOAD PACKAGES

library("qualtRics")
library("httr")
library("tidyr")
library("reshape2")
library("psych")
library("yarrr")
library("car")
library("effectsize")
library("BayesFactor")

#FETCH THE DATA FROM OSF 

#The line below downloads the data csv file from oSF to your working directory, saved as "study2.csv"  credit: https://twitter.com/lakens/status/839469115253325824   
data<-GET('https://osf.io/fteub/?action=download', write_disk('study2.csv', overwrite = TRUE))


#The line below reads the data from your working directory using the qualtRics 'readSurvey' function. This function strips out the text in rows 2 and 3 (among other useful things)
mydata=readSurvey("study2.csv")

 

#CONVERT mydata to a data.frame 
#'mydata' is a tibble rather than a data.frame (this is due to the way that the qualtRics package Formats the data)
#The code below converts mydata into a data.frame (**doing this this avoids problems further down the line)
mydata<- as.data.frame(mydata)
mydata

#Count how many particpants consented to take part (this is BEFORE any exclusions for non-completion / non-serious responding) 
length(which(mydata$Consent==1))

#OPTIONAL: the line below identifies the types of variable we have (e.g., numeric, string, character etc.) - Just to check that qualtRics readSurvey has worked properly (i.e. to check whether it has set all relevant columns to 'numeric') 
sapply(mydata, class)



#rename variables that have odd names 
colnames(mydata)[colnames(mydata)=="SC0"] <- "recall_score"
colnames(mydata)[colnames(mydata)=="FL_12_DO"] <- "condition"




#EXCLUDE PARTICIPANTS IF THEY DON'T MEET PREREGISTERED INCLUSION CRITERIA 
#create a new data.frame that is a SUBSET of the original. This data.frame...
#1) only includes SUBSET of participants who finished the study (Finished==1) AND declared that they answered seriously (seriousness_check==1) AND scored 4 or above on recall - i.e., excluding non-completers, non-serious responses and those who did not recall 4 or more items  
#2) only includes SUBSET of relevant columns required for analysis

mydata <- subset(mydata, Finished==1 & Serious_check==1 & recall_score>=4, select=c(Finished, `Duration (in seconds)`, Gender, Age, Serious_check, recall_score, condition, NC_1:Development_sci_know_6))

#Count how many particpants remain after exclusions (final sample size)
length(which(mydata$Serious_check==1))

#Calculate mean completion time in seconds 
mean(mydata$`Duration (in seconds)`) #653.68
#Convert to minutes 
653.68/60 #10.89467

#OPTIONAL: export the data to a .csv to check it all looks in order (i.e. correct rows and columns retained? / only those who completed seriously retained?)
write.csv(mydata, file = "MyDataTidied.csv")



#DEMOGRAPHICS

#count up how many pps assigned to each of the four conditions 
length(which(mydata$condition=="Block_1_Generic_Conflict"))   #98
length(which(mydata$condition=="Block_2_Generic_Consistent"))   #101
length(which(mydata$condition=="Block_3_Qualified_Conflict"))    #101
length(which(mydata$condition=="Block_4_Qualified_Consistent"))   #100


#total n (after exclusions)
nrow(mydata)
Total_n <- nrow(mydata)

#Age
mean(mydata$Age,na.rm=TRUE)
sd(mydata$Age,na.rm=TRUE)
min(mydata$Age,na.rm=TRUE)
max(mydata$Age,na.rm=TRUE)

#Gender 
#count of Males  
length(which(mydata$Gender==1))
Males<- length(which(mydata$Gender==1))
PercentMale <- (Males/Total_n)*100
#count of Females  
length(which(mydata$Gender==2))
Females<- length(which(mydata$Gender==2))
PercentFemale <- (Females/Total_n)*100
#count of 'Other'
length(which(mydata$Gender==3))
Other<- length(which(mydata$Gender==3))
PercentOther <- (Other/Total_n)*100
#count of 'Prefer not to say'
length(which(mydata$Gender==4))
Prefer_not_say <-length(which(mydata$Gender==4))
PercentPreferNot <- (Prefer_not_say/Total_n)*100
#print counts
Total_n
Males
Females
Other
Prefer_not_say
#print percentages
PercentMale
PercentFemale
PercentOther
PercentPreferNot


#create sepearte columns to identify levels of each IV  (original 'condition' Format is "Block_1_Generic_Conflict" - this just splits into four speerate columns using underscore as delimiter  - 'block' and 'number' are meaningless - Format and Conflict are the IVs)

mydata<- separate(data = mydata, col = condition, into = c("block", "number", "Format", "Conflict"))


#look at the results of this command 
write.csv(mydata, file = "MyDataTidied.csv")
 



#rename Generic=Gen.,  Qualified=Qual.   (this is for the benefit of the pirate plot below to avoid overwriting )
mydata$Conflict <- gsub("Conflict", "Conf.", mydata$Conflict)
mydata$Conflict <- gsub("Consistent", "Non-Conf.", mydata$Conflict) 






#set these new IV columns as factors 
mydata$Format <- as.factor(mydata$Format)
levels(mydata$Format)

mydata$Conflict <- as.factor(mydata$Conflict)
levels(mydata$Conflict)






#score the scales  (reverse scoring not required as items were reverse coded within Qualtrics)  
#calulated the average for each scale 

#nutrional confusion mean
mydata$confusion <- ((mydata$NC_1 + mydata$NC_2 + mydata$NC_3 + mydata$NC_4 + mydata$NC_5 + mydata$NC_6)/6)

#nutrional backlash mean
mydata$backlash <- ((mydata$NBS_1 + mydata$NBS_2 + mydata$NBS_3 + mydata$NBS_4 + mydata$NBS_5 + mydata$NBS_6)/6)  
 
#Mistrust of expertise mean
mydata$mistrust <- ((mydata$Mistrust_expertise_1 + mydata$Mistrust_expertise_2 + mydata$Mistrust_expertise_3)/3)

#Certainty of knowledge mean
mydata$certainty <- ((mydata$Certainty_sci_know_1 + mydata$Certainty_sci_know_2 + mydata$Certainty_sci_know_3 + mydata$Certainty_sci_know_4 + mydata$Certainty_sci_know_5 + mydata$Certainty_sci_know_6)/6)

#Development of knowledge mean
mydata$development <- ((mydata$Development_sci_know_1 + mydata$Development_sci_know_2 +mydata$Development_sci_know_3 +mydata$Development_sci_know_4 +mydata$Development_sci_know_5 +mydata$Development_sci_know_6)/6)

#OPTIONAL: the line below identifies the types of variable we have (e.g., numeric, string, character etc.) - Just to check that qualtRics readSurvey has worked properly (i.e. to check whether it has set all relevant columns to 'numeric') 
sapply(mydata, class)


#look at the results of these command (5 new columns)
write.csv(mydata, file = "MyDataTidied.csv")



  
#chronbachs alphas  (use psych package)  
confusion_alpha <- subset(mydata, select=c(NC_1:NC_6))
psych::alpha(confusion_alpha)  
  
backlash_alpha <- subset(mydata, select=c(NBS_1:NBS_6))
psych::alpha(backlash_alpha)    
  
mistrust_alpha <-subset(mydata, select=c(Mistrust_expertise_1:Mistrust_expertise_3))
psych::alpha(mistrust_alpha)

certainty_alpha <-subset(mydata, select=c(Certainty_sci_know_1:Certainty_sci_know_6))
psych::alpha(certainty_alpha)

development_alpha <-subset(mydata, select=c(Development_sci_know_1:Development_sci_know_6))
psych::alpha(development_alpha)




#pirate plots  / descriptives 

par(mfrow = c(3, 2)) #will pace plots in a grid with 3 rows and 2 columns 


pirateplot(formula = confusion ~ Conflict*Format, data = mydata, yaxt = "n", theme=1,main = "Nutritional Confusion", ylab = "Nutritional Confusion", cex.names = 0.75, cex.lab = 0.9, inf.method = 'ci')
axis(2, at = seq(from = 1, to = 5, by = 1)) 

pirateplot(formula = backlash ~ Conflict*Format, data = mydata, yaxt = "n", theme=1,main = "Nutritional Backlash", ylab = "Nutritional Backlash", cex.names = 0.75, cex.lab = 0.9, inf.method = 'ci')
axis(2, at = seq(from = 1, to = 5, by = 1)) 

pirateplot(formula = mistrust ~ Conflict*Format, data = mydata, yaxt = "n", theme=1,main = "Mistrust of Expertise", ylab = "Mistrust of expertise", cex.names = 0.75, cex.lab = 0.9, inf.method = 'ci')
axis(2, at = seq(from = 1, to = 5, by = 1)) 

pirateplot(formula = GSS ~ Conflict*Format, data = mydata, yaxt = "n", theme=1,main = "Confidence in Scientific Community", ylab = "Confidence in Scientific Community", cex.names = 0.75, cex.lab = 0.9, inf.method = 'ci')
axis(2, at = seq(from = 1, to = 3, by = 1)) 

pirateplot(formula = certainty ~ Conflict*Format, data = mydata, yaxt = "n", theme=1,main = "Certainty of Knowledge", ylab = "Certainty of knowledge", cex.names = 0.75, cex.lab = 0.9, inf.method = 'ci')
axis(2, at = seq(from = 1, to = 5, by = 1)) 

pirateplot(formula = development ~ Conflict*Format, data = mydata,yaxt = "n", ylim =c(1,5), theme=1,main = "Development of Knowledge", ylab = "Development of knowledge", cex.names = 0.75, cex.lab = 0.9, inf.method = 'ci')
axis(2, at = seq(from = 1, to = 5, by = 1))
#Note that I added   ylim =c(1,5)   here because the default scale went from 3-5 rather than 1-5 (presumably because there were no scores of 1 or 2)                 

#remember to set grid back to default (just one plot)
par(mfrow = c(1, 1))




#print descriptives that pirate plots are based on
confusion.pp <- pirateplot(formula = confusion ~ Conflict*Format,data = mydata,plot = FALSE)
confusion.pp

backlash.pp <- pirateplot(formula = backlash ~ Conflict*Format,data = mydata,plot = FALSE)
backlash.pp

mistrust.pp <- pirateplot(formula = mistrust ~ Conflict*Format,data = mydata,plot = FALSE)
mistrust.pp

GSS.pp <- pirateplot(formula = GSS ~ Conflict*Format,data = mydata,plot = FALSE)
GSS.pp

certainty.pp <- pirateplot(formula = certainty ~ Conflict*Format,data = mydata,plot = FALSE)
certainty.pp

development.pp <- pirateplot(formula = development ~ Conflict*Format,data = mydata,plot = FALSE)
development.pp










#Inferential stats  2x2 ANOVA  (using car package: car  uses Type 3 SS to be consistent with SPSS)   https://www.rdocumentation.org/packages/car/versions/1.0-7/topics/Anova  

#Conflict and Format were set as.factors earlier 

#this line turns off scientific notation for p values 
options(scipen=999) 

#This guide tells us how to get the same output values as SPSS. It involves changing the default contrast settings and using type III sum of squares http://www.statscanbefun.com/rblog/2015/8/27/ensuring-r-generates-the-same-anova-f-values-as-spss 
#It tells us change default contrasts using the command below   
options(contrasts = c("contr.helmert", "contr.poly"))


#nutrional confusion
confusionlm <- lm(confusion ~ Conflict*Format, data = mydata)   #we first create a linear model 
Anova(confusionlm,type=3)    #we then use the car package calculates Anova (with type 3 SS) on the linear modelwe have just created  
cohens_f(confusionlm, partial = TRUE, ci = 0.95, squared = FALSE, model2 = NULL)

#Bayesian nutritional confusion ANOVA 
confusion_bayes <- anovaBF(confusion ~ Conflict*Format, data = mydata)
confusion_bayes # lists the Bayes factor for each model against the null model

#whichModels = "all" computes Bayes factors for all models
confusion_bayes_all <- anovaBF(confusion ~ Conflict*Format, whichModels = "all", data = mydata)
confusion_bayes_all 


#nutritional backlash
backlashlm <- lm(backlash ~ Conflict*Format, data = mydata)   
Anova(backlashlm,type=3)    
cohens_f(backlashlm, partial = TRUE, ci = 0.95, squared = FALSE, model2 = NULL)

#Bayesian nutritional backlash ANOVA 
backlash_bayes <- anovaBF(backlash ~ Conflict*Format, data = mydata)
backlash_bayes # lists the Bayes factor for each model against the null model

#whichModels = "all" computes Bayes factors for all models
backlash_bayes_all <- anovaBF(backlash ~ Conflict*Format, whichModels = "all", data = mydata)
backlash_bayes_all 


#mistrust
mistrustlm <- lm(mistrust ~ Conflict*Format, data = mydata)   
Anova(mistrustlm,type=3) 
cohens_f(mistrustlm, partial = TRUE, ci = 0.95, squared = FALSE, model2 = NULL)

#Bayesian mistrust ANOVA 
mistrust_bayes <- anovaBF(mistrust ~ Conflict*Format, data = mydata)
mistrust_bayes # lists the Bayes factor for each model against the null model

#whichModels = "all" computes Bayes factors for all models
mistrust_bayes_all <- anovaBF(mistrust ~ Conflict*Format, whichModels = "all", data = mydata)
mistrust_bayes_all 


#confidence
GSSlm <- lm(GSS ~ Conflict*Format, data = mydata)   
Anova(GSSlm,type=3) 
cohens_f(GSSlm, partial = TRUE, ci = 0.95, squared = FALSE, model2 = NULL)

#Bayesian confidence ANOVA 
GSS_bayes <- anovaBF(GSS ~ Conflict*Format, data = mydata)
GSS_bayes # lists the Bayes factor for each model against the null model

#whichModels = "all" computes Bayes factors for all models
GSS_bayes_all <- anovaBF(GSS ~ Conflict*Format, whichModels = "all", data = mydata)
GSS_bayes_all 


#certainty
certaintylm <- lm(certainty ~ Conflict*Format, data = mydata) Anova(certaintylm,type=3) 
cohens_f(certaintylm, partial = TRUE, ci = 0.95, squared = FALSE, model2 = NULL)

#Bayesian certainty ANOVA 
certainty_bayes <- anovaBF(certainty ~ Conflict*Format, data = mydata)
certainty_bayes # lists the Bayes factor for each model against the null model

#whichModels = "all" computes Bayes factors for all models
certainty_bayes_all <- anovaBF(certainty ~ Conflict*Format, whichModels = "all", data = mydata)
certainty_bayes_all 


#development 
developmentlm <- lm(development ~ Conflict*Format, data = mydata)   
Anova(developmentlm,type=3) 
cohens_f(developmentlm, partial = TRUE, ci = 0.95, squared = FALSE, model2 = NULL)

#Bayesian development ANOVA 
development_bayes <- anovaBF(development ~ Conflict*Format, data = mydata)
development_bayes # lists the Bayes factor for each model against the null model

#whichModels = "all" computes Bayes factors for all models
development_bayes_all <- anovaBF(development ~ Conflict*Format, whichModels = "all", data = mydata)
development_bayes_all 





#####ORDINAL REGRESSION####
library("foreign") #load packages
library("ggplot2")
library("MASS")
library("Hmisc")
library("reshape2")


#assign a label to the value
mydata$GSSvalue <- ordered(mydata$GSS,
                                 levels = c(1, 2, 3),
                                 labels = c("A great deal", "Only some", "Hardly any")) 


#specify reference category
mydata$Format <- relevel(mydata$Format, ref = "Generic") 
mydata$Conflict <- relevel(mydata$Conflict, ref = "Conf.") 



####GSS ordinal regression
GSS_or <- polr(as.factor(GSSvalue) ~ Conflict * Format, data = mydata, Hess = TRUE)
GSS_or #print summary


#Compute confusion table and misclassification error
#The confusion matrix shows the performance of the ordinal logistic regression model
predict_GSS = predict(GSS_or, mydata)
table(mydata$GSSvalue, predict_GSS)
mean(as.character(mydata$GSSvalue) != as.character(predict_GSS))

#store table
(GSS_table <- coef(summary(GSS_or)))

#calculate and store p values
GSS_p <- pnorm(abs(GSS_table[, "t value"]), lower.tail = FALSE) * 2

#combined table
(GSS_table <- cbind(GSS_table, "p value" = GSS_p)) 

(GSS_ci <- confint(GSS_or)) #default method gives profiled CIs
confint.default(GSS_or) #CIs assuming normality

#odds ratios
exp(coef(GSS_or))

#OR and CI
exp(cbind(OR = coef(GSS_or), GSS_ci))
